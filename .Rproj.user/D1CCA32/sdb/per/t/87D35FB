{
    "collab_server" : "",
    "contents" : "\n#' Detect edges in co-expression datasete.\n#'\n#' Fit the L2N model to normalized correlation coefficients between pairs of genes. The mixture model has three component - the null component follows a normal distribution, and the two non-null components follow lognormal distributions. An edge is in the graph if the correlation between the two end-point genes is large enough and determined to be in one of the non-null components.\n#' @param Exprs A numeric matrix with normalized gene expression data. Rows\n#' correspond to genes, and columns correspond to samples.\n#' @param BHthr the Benjamini-Hochberg fasle discovery rate threshold to be\n#' used to determine which pairs are strongly correlated. Default=0.05.\n#' @param rndseed The random seed used to select a subset of the pairs.\n#' @param maxLen The maximum number of pairs that will be randomly selected\n#' to fit the L2N model. Default=20000.\n#' @param LOvals the maximum log-odds ratio to be used to be used to\n#' determine the cut-off points to declare which correlations are significant.\n#' The program will check which log-odds ratio (1,2,...,LOvals) results in\n#' FDR less than or equal to BHthr.\n#' Default=20.\n#' @param ttl Title for the fitted-model plot. Default=\"\"\n#' @return A list with the following elements\n#' \\itemize{\n#'  \\item{G} {The number of genes}\n#' \\item{p1} {The proportion of genes in the right mixture component (positively correlated.)}\n#' \\item{p2} {The proportion of genes in the left mixture component (negtively correlated.)}\n#' \\item{p0} {The proportion of genes in the null component (un-correlated.)}\n#' \\item{m0, m1, m2, s0, s1, s2} {The location and scale parameters of the three mixture components.}\n#' \\item {thrtable} {A table with 6 columns: posterior probability ratio (ppr) between the non-null components and the null component), the right component cutoff corresponding to the ppr, the left component cutoff, the estimated probability of Type-I errors, the estimated power, the estimated FDR.}\n#' \\item {LogOddsRatio} {The log-odds ratio that yields FDR less than or equal to the desired level.}\n#' \\item {rmse} {The root mean-squared error of the fitted model.}\n#' \\item {rt, lt} {The significant edges (from the right, and left mixture component.)}\n#' }\n#' @export\n#' @examples\n#' \\donttest{\n#'    data(WT)\n#'    WTres <- edgefinder(WT, ttl = \"Wild Type\")\n#' }\n\nedgefinder <- function(Exprs, BHthr = 0.05,\n                       rndseed=112211, maxLen=20000, LOvals=20, ttl=\"\") {\n  corM <- cor(t(Exprs), use = \"pairwise.complete.obs\")\n  N <- ncol(Exprs)\n  y <- atanh(corM[upper.tri(corM)])\n  fix <- which(is.infinite(y))\n  if (length(fix) > 0)\n    y[fix] <- max(abs(y[-fix]))*(1 + runif(length(fix)))\n  set.seed(rndseed)\n  sset <- sample(1:length(y),size = min(maxLen,length(y)))\n  y0 <- y[sset]\n  fittedL2N <- EM(y0*sqrt(N-3), fixedNullVar = F)\n  rmseL2N <- GoodnessOfFit(fittedL2N)\n  plotMixture(fittedL2N,gof=rmseL2N,trim=0, ttl=ttl)\n  B <- posteriorDensityL2N(fittedL2N, y*sqrt(N-3))\n  p1L2N <- mean(fittedL2N$b1)\n  p2L2N <- mean(fittedL2N$b2)\n  p0L2N <- 1-(p1L2N+p2L2N)\n  m0L2N = fittedL2N$theta\n  m1L2N = fittedL2N$mu1\n  m2L2N = fittedL2N$mu2\n  s0L2N = fittedL2N$tau\n  s1L2N = fittedL2N$s1\n  s2L2N = fittedL2N$s2\n\n  ret = logoddsValues(fittedL2N$x,m0L2N,s0L2N,m1L2N,\n                      s1L2N,m2L2N,s2L2N,p1L2N,p2L2N,\n                      vals=1:LOvals)\n  if (length(which(ret[,6] < BHthr) > 0)) {\n    LogOddsRatio <- max(min(which(ret[,6] < BHthr)),2)\n  } else {\n    LogOddsRatio <- LOvals\n  }\n  RtBFL2N <- which(B[[2]]/B[[1]] > LogOddsRatio)\n  LtBFL2N <- which(B[[3]]/B[[1]] > LogOddsRatio)\n\n  list(G=nrow(Exprs), p1=p1L2N, p2=p2L2N, p0=p0L2N, m0=m0L2N, m1=m1L2N, m2=m2L2N,\n       s0=s0L2N, s1=s1L2N, s2=s2L2N, thrtable=ret, LogOddsRatio=LogOddsRatio,\n       rmse=rmseL2N, rt=RtBFL2N, lt=LtBFL2N)\n}\n\n#' Print a short summary of the fitted mixture model.\n#'\n#' Show the number of nodes, the number of possible edges, the proportion of possitively/negatively correlated pairs, the estimated power and false discovery rate.\n#' @param edgefinderobj The object (list) returned from the edgefinder function.\n#' @export\n#' @examples\n#' \\donttest{\n#'    data(WT)\n#'    WTres <- edgefinder(WT, ttl = \"Wild Type\")\n#'    shortSummary(WTres)\n#' }\nshortSummary <- function(edgefinderobj) {\n  with(edgefinderobj,{\n    cat(\"No. nodes =\", prettyNum(G,big.mark = \",\"),\"\\n\")\n    cat(\"Max no. edges =\", prettyNum(choose(G, 2),big.mark = \",\"),\"\\n\")\n    cat(\"p1 =\",format(p1,digits=3),\"\\n\")\n    cat(\"p2 =\",format(p2,digits=3),\"\\n\")\n    cat(\"Est. Power =\", format(thrtable[LogOddsRatio,5],digits=3),\"\\n\")\n    cat(\"Est. FDR =\", format(thrtable[LogOddsRatio,6],digits=3),\"\\n\")\n  })\n}\n\n# The EM algorithm to fit the L2N model.\n#\n# Fit the L2N model to normalized correlation coefficients between pairs of genes. The mixture model has three component - the null component follows a normal distribution, and the two non-null components follow lognormal distributions. An edge is in the graph if the correlation between the two end-point genes is large enough and determined to be in one of the non-null components.\n# @param x A vector of normalized correlation coefficients\n# @param max.it The maximum number of EM algorithm iterations (default=1000)\n# @param tol The tolerance level to assess convergence of the EM algorithm (default=1e-12.)\n# @return A list of the parameter estimates for the L2N model.\n# @export\nEM <- function(x, max.it=1000, tol=1e-12, mixturemodel= \"L2N\",\n               fixedNullVar=FALSE) {\n  N   <- length(x)\n  err <- 1\n  # initialize the parameter values\n  adjustMean <- mean(x) # centering the data around the mean\n  x <- x - adjustMean\n  # The parameters of the null ditribution, N(theta,tau) :\n  theta <- mean(x)\n  tau   <- 1\n  # The location and scale parameters of the nonnull components:\n  mu    <- abs(quantile(x,c(0.05,.95)))\n  names(mu) <- c()\n  sig   <- c(1, 1)\n  # The initial probabilities of the three components:\n  p0 <- 0.98\n  p1 <- 0.01\n  p2 <- 0.01\n  # Set the initial component indicator variables:\n  b1 <- rep(0,N)\n  b2 <- rep(0,N)\n  m1 <- 0\n  m2 <- 0\n  ct <- 0\n  # Run the EM algorithm until the mixture fits the empirical\n  # density well (total squared errors < tol)\n  while (err > tol) {\n    adjustMean <- adjustMean + theta\n    x   <- x - theta # iteratively center the data, so that the mean of the\n    # null component ends up being 0\n    pos <- which(x > 0) # Fit the nonnull components according to the\n    neg <- which(x < 0) #      sign of x\n\n    d0 <- dnorm(x, theta, tau) # null component is normal\n    d1 <- dlnorm(x, mu[1], sig[1])\n    d2 <- dlnorm(-x, mu[2], sig[2])\n    wtsm <- p0*d0 + p1*d1 + p2*d2    # The density of the mixture\n    b1[-pos] <- 0\n    b2[-neg] <- 0\n    b1[pos] <- pmin(1,p1*d1[pos]/wtsm[pos])  # Posterior probabilities of the positive nonnull\n    b2[neg] <- pmin(1,p2*d2[neg]/wtsm[neg])  # Posterior probabilities of the negative nonnull\n    b0      <- 1 - (b1+b2)           # The posterior null probabilities\n    # Update the component weights:\n    p0 <- mean(b0)\n    p1 <- mean(b1)\n    p2 <- mean(b2)\n    # Update the null component parameters:\n    theta <- sum(b0*x)/sum(b0)\n    if (fixedNullVar)\n      tau <- 1\n    else\n      tau  <- sqrt(sum(b0*(x-theta)^2)/sum(b0))\n    d0    <- dnorm(x, theta, tau)\n    # Update the nonnull (nonnull) components parameters:\n    if (sum(b1[pos]) < 1e-2) {\n      mu[1]  <- 0\n      sig[1] <- 0\n      d1     <- rep(0, N)\n    } else {\n      mu[1]  <- sum(b1[pos]*(log(x[pos])))/sum(b1[pos])\n      sig[1] <- sqrt(sum(b1[pos]*(log(x[pos])-mu[1])^2)/sum(b1[pos]))\n      d1     <- dlnorm(x, mu[1], sig[1])\n    }\n\n    if (sum(b2[neg]) < 1e-2) {\n      mu[2]  <- 0\n      sig[2] <- 0\n      d2     <- rep(0, N)\n    } else {\n      mu[2]  <- sum(b2[neg]*(log(-x[neg])))/sum(b2[neg])\n      sig[2] <- sqrt(sum(b2[neg]*(log(-x[neg])-mu[2])^2)/sum(b2[neg]))\n      d2     <- dlnorm(-x, mu[2], sig[2])\n    }\n\n    # Check convergence\n    err <- sum((p0*d0 + p1*d1 + p2*d2 - wtsm)^2)\n    ct <- ct + 1\n    if(ct > max.it)\n      break\n  }\n  b1[-pos] <- 0\n  b2[-neg] <- 0\n  b1[pos] <- pmin(1,p1*d1[pos]/wtsm[pos])  # Posterior probabilities of the positive nonnull\n  b2[neg] <- pmin(1,p2*d2[neg]/wtsm[neg])  # Posterior probabilities of the negative nonnull\n  b0      <- 1 - (b1+b2)           # The posterior null probabilities\n  pvals <- 2*(1-pnorm(abs(x), mean=0, sd=tau))\n  bh <- p.adjust(pvals, method=\"BH\")\n  #qvals <- qvalue(pvals)$qvalues\n  list(x=x, adjustMean=adjustMean,\n       theta=theta, tau=tau,\n       mu1=mu[1], s1=sig[1],\n       mu2=mu[2], s2=sig[2],\n       b0=b0, b1=b1, b2=b2,\n       p.val=pvals, bh=bh,\n       #q.val=qvals,\n       err=err, its=ct)\n}\n\n# Calculate the log-odds ratios to determine for each gene, in which\n# of the three components in the L2N model, it belongs\nlogoddsValues <- function(y,theta,tau,mu1,s1,mu2,s2,p1,p2,\n                          mixturemodel=\"L2N\",vals=1:10) {\n  ret = matrix(0,nrow=length(vals),ncol=6)\n  ret[,1] = vals\n  p0 = 1-p1-p2\n  xs <- seq(min(y),max(y),length=10000)\n  pxs <- seq(1e-6,max(y),length=10000)\n  nxs <- seq(min(y),-1e-6,length=10000)\n  i=0\n  for (val in vals) {\n    i = i + 1\n    if (p1 < 1/length(y)) {\n      ret[i,2] <- Inf\n    } else {\n      f <- function(x) { log((p1*dlnorm(x, mu1, s1))/\n                               (p0*dnorm(x,  theta, tau)))-log(val) }\n      rt <- try(uniroot(f,  lower = 1e-6, upper = max(y)), silent = T)\n      if (class(rt) == \"try-error\")\n        ret[i,2] = Inf\n      else\n        ret[i,2] = rt$root\n    }\n    if (p2 < 1/length(y)) {\n      ret[i,3] <- -Inf\n    } else {\n      f <- function(x) { log((p2*dlnorm(-x, mu2, s2))/\n                               (p0*dnorm(x,  theta, tau)))-log(val) }\n      rt <- try(uniroot(f,  lower = min(y), upper = -1e-6), silent = T)\n      if (class(rt) == \"try-error\")\n        ret[i,3] = -Inf\n      else\n        ret[i,3] = rt$root\n    }\n    # type I:\n    ret[i,4] = pnorm(ret[i,3], theta, tau) +\n      1 - pnorm(ret[i,2], theta, tau)\n    # Power:\n    ret[i,5] = (p1*(1-plnorm(ret[i,2], mu1, s1)) +\n                  p2*(1-plnorm(-ret[i,3], mu2, s2)))/(p1+p2)\n    # FDR:\n    ret[i,6] <- p0*ret[i,4]/(p0*ret[i,4]+ret[i,5]*(p1+p2))\n  }\n  colnames(ret) <- c(\"ppr\",\"Right\",\"Left\",\"TypeI\",\"Power\",\"FDR\")\n  ret\n}\n\n# calculate the posterior L2N mixture model density of x, given the parameter\n# estimates\nposteriorDensityL2N <- function(fit.em, x) {\n  p0 <- mean(fit.em$b0)\n  p1 <- mean(fit.em$b1)\n  p2 <- mean(fit.em$b2)\n  adjustMean <- fit.em$adjustMean + fit.em$theta\n  x   <- x - fit.em$adjustMean\n  pos <- which(x > 0) # Fit the nonnull components according to the\n  neg <- which(x < 0) #      sign of x\n  d0 <- dnorm(x, fit.em$theta, fit.em$tau) # null component is normal\n  d1 <- dlnorm(x, fit.em$mu1, fit.em$s1)\n  d2 <- dlnorm(-x, fit.em$mu2, fit.em$s2)\n  wtsm <- p0*d0 + p1*d1 + p2*d2\n  b1 <- rep(0, length(x))\n  b2 <- rep(0, length(x))\n  b1[pos] <- pmin(1,p1*d1[pos]/wtsm[pos])  # Posterior probabilities of the positive nonnull\n  b2[neg] <- pmin(1,p2*d2[neg]/wtsm[neg])  # Posterior probabilities of the negative nonnull\n  b0      <- 1 - (b1+b2)           # The posterior null probabilities\n  list(b0=b0,b1=b1,b2=b2)\n}\n\n# Return the estimated density function of the mixture\nmixtureDensityL2N <- function(fit.em, x) {\n  mean(fit.em$b0)*dnorm(x, fit.em$theta, fit.em$tau) +\n    mean(fit.em$b1)*dlnorm(x, fit.em$mu1, fit.em$s1) +\n    mean(fit.em$b2)*dlnorm(-x, fit.em$mu2, fit.em$s2)\n}\n\n# Calculate the root mean squared error of the fitted mixture\nGoodnessOfFit <- function(fit.em, mixturemodel=\"L2N\") {\n  x <- sort(fit.em$x)\n  if(length(x) > 10000)\n    x <- x[seq(1,length(x), length=10000)]\n  diffs <- x[-1] - x[-length(x)]\n  dnsfn <- approxfun(density(x,bw=\"SJ\"))\n  return(sqrt(sum((diffs* (dnsfn(x[-1])-mixtureDensityL2N(fit.em,x[-1])) ^2))))\n}\n\n# create clusters of nodes, based on similarity of their edges\nclustNode <- function(A) {\n  degs <- rowSums(A)\n  deg1copy <- degs\n  ord <- rev(order(degs))\n  while(max(deg1copy) >= 0) {\n    maxdeg <- which.max(deg1copy)\n    nbrs <- which(A[maxdeg,] == 1)\n    nbrs <- setdiff(nbrs, which(deg1copy < 0))\n    deg1copy[maxdeg] <- -length(which(deg1copy < 0)) -1\n    if (length(nbrs) == 0)\n      next\n    extdeg <- rep(0, length(nbrs))\n    for (i in 1:length(nbrs)) {\n      nbr <- nbrs[i]\n      extdeg[i] <- length(setdiff(which(A[nbr,] == 1), nbrs)) + # external links\n        length(setdiff(nbrs, which(A[nbr,] == 0)))  # missing internal links\n    }\n    deg1copy[nbrs[rev(order(extdeg[nbrs]))]] <- -length(which(deg1copy < 0)) - 1:length(nbrs)\n  }\n  deg1copy\n}\n\n# calculate the clustering coefficient of a node\nclusteringCoef <- function(A) {\n  rsum <- rowSums(A)\n  cc <- rep(0,nrow(A))\n  for (i in 1:nrow(A)) {\n    if (rsum[i] <= 1)\n      cc[i] <- 0\n    else {\n      nbrs <- which(A[i,] == 1)\n      At <- A[nbrs, nbrs]\n      cc[i] <- 0.5*sum(At)/choose(rsum[i],2)\n    }\n  }\n  cc\n}\n\n#' Plot the histogram of the data and the fitted mixture distribution.\n#'\n#' The function is called by the edgefinder function.\n#' @param fit.em The object (list) returned from the EM function with the parameter estimates for the L2N model.\n#' @param gof The root mean-squared error of the fitted model (to appear in the title of the plot).\n#' @param ttl The title of the plot (default=\"\").\n#' @param trim The proportion of extreme values on both sides of the distribution to eliminate from the plot (default=0.01.) This can be useful if a small number of values are so extreme, that the plot shows mostly the tails and a spike in the middle.\n#' @export\nplotMixture <- function(fit.em, gof, ttl=\"\", xlab=\"x\", trim=0.01,\n                        mixturemodel=\"L2N\") {\n  xlim <- quantile(fit.em$x, c(trim/2, 1-trim/2))\n  brks <- min(80,floor(length(fit.em$x)/100))\n  hist(fit.em$x, freq=FALSE, breaks=brks,\n       main=sprintf(\"%s\\nrMSE %2.2f\",ttl, gof),\n       xlim=xlim,xlab=xlab, border=\"white\", col=\"wheat\")\n  xs <- seq(min(fit.em$x), max(fit.em$x), length=1000)\n  p0 <- mean(fit.em$b0)\n  p1 <- mean(fit.em$b1)\n  p2 <- mean(fit.em$b2)\n  lines(xs,  p0*dnorm(xs,  fit.em$theta, fit.em$tau), col=2, lwd=2)\n  lines(xs,  p1*dlnorm(xs, fit.em$mu1,   fit.em$s1),  col=3, lwd=2)\n  lines(-xs, p2*dlnorm(xs, fit.em$mu2,   fit.em$s2),  col=3, lwd=2)\n  mxfit <- p0*dnorm(xs,fit.em$theta, fit.em$tau) +\n    p1*dlnorm(xs, fit.em$mu1, fit.em$s1) +\n    p2*dlnorm(-xs, fit.em$mu2, fit.em$s2)\n  lines(xs, mxfit, lwd=3, col=4, lty=2)\n}\n\n#' Plot the degree of nodes versus the degree times the clustering coefficients.\n#'\n#' The x-axis represents the number of neighbors of each node, and the y-axis represents the proportion of neighbors which are connected to each other.\n#' @param edgefinderobj The object (list) returned by edgefinder.\n#' @export\n#' @examples\n#' \\donttest{\n#'    data(WT)\n#'    WTres <- edgefinder(WT, ttl = \"Wild Type\")\n#'    plotDegCC(WTres)\n#' }\n\nplotDegCC <- function(edgefinderobj) {\n    sigW <- sort(union(edgefinderobj$rt,edgefinderobj$lt))\n    G <- edgefinderobj$G\n    tmpmat <- Matrix(0,G, G)\n    vec <- rep(0, choose(G,2))\n    vec[sigW] <- 1\n    tmpmat[upper.tri(tmpmat)] = vec\n    A0 <- tmpmat+t.data.frame(tmpmat)\n    cc0 <- clusteringCoef(as.matrix(A0))\n    deg0 <- rowSums(as.matrix(A0))\n    lm0 <- lm(sqrt(deg0*cc0) ~ sqrt(deg0))\n    M <- max(deg0)\n    plot(deg0, deg0*cc0,axes=F,xlim=c(0,M),\n         ylim=c(0,M),main=\"\",\n         xlab=bquote(\"degree\"),ylab=bquote(\"CC*degree\"),\n         col=\"thistle\",pch=24,cex=0.5); axis(1); axis(2)\n    grid(); abline(0,1,col=\"seagreen1\", lwd=2)\n    sq <- seq(0,M,length=length(deg0))\n    newdat = data.frame(deg0 = sq)\n    pred = predict.lm(lm0, newdata=newdat)\n    lines(sq, pred^2, col=\"orange\",lwd=3,lty=2)\n}\n\n#' Edge-indicator bitmap plot.\n#'\n#' Plot a bitmap in which a black dot corresponds to a pair of highly correlated genes (an edge in the graph).\n#' The default is to show the nodes according to their order in the input.\n#' By setting orderByDegree=T as below, it is possible to change the order and cluster them, and show them in increasing degree order (from left to right.)\n#' @param edgefinderobj The object (list) returned by edgefinder.\n#' @export\n#' @examples\n#' \\donttest{\n#'    data(WT)\n#'    WTres <- edgefinder(WT, ttl = \"Wild Type\")\n#'    plotBitmapCC(WTres)\n#'    WTres$orderByDegree=T\n#'    plotBitmapCC(WTres)\n#' }\nplotBitmapCC <- function(edgefinderobj) {\n  with(edgefinderobj,{\n    sigW <- sort(union(rt,lt))\n    tmpmat <- Matrix(0,G, G)\n    vec <- rep(0, choose(G,2))\n    vec[sigW] <- 1\n    tmpmat[upper.tri(tmpmat)] = vec\n    A0 <- tmpmat+t.data.frame(tmpmat)\n    deg0copy <- clustNode(as.matrix(A0))\n    if (\"orderByDegree\" %in% ls()) {\n      if (orderByDegree)\n        image(A0[order(deg0copy), order(deg0copy)])\n      else\n        image(A0)\n    } else {\n      image(A0)\n    }\n  })\n}\n",
    "created" : 1536637894659.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "329483066",
    "id" : "87D35FB",
    "lastKnownWriteTime" : 1536432023,
    "last_content_update" : 1536432023,
    "path" : "~/Box/CorNetwork_Project/edgefinder/R/edgefinder.R",
    "project_path" : "R/edgefinder.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}